\ Raz standard library
\ Backslash comments have been defined by now
: / /mod swap drop ; 
: mod /mod drop ;
\ define the if/then construct
: if immediate ' 0branch , here @ # 0 , ; 
: then immediate dup here @ swap - swap ! ;
\ comparison and boolean values
: true # -1 ;
: false # 0 ;
: 0= # 0 = ;
: not 0= ;
: <> = not ;
: <= > not ;
: >= < not ; 
: 0> # 0 > ;
: 0< # 0 < ;
: 0<= # 0 <= ;
: 0>= # 0 >= ;
: 0<> 0= not ;
: bin # 2 Base ! ;
: octal # 8 Base ! ;
: hex # 16 Base ! ;
: decimal # 10 Base ! ;
: abs dup # 0 < if negate then ;
: /0 dup # 0 = if exit then / ;
: sign dup # 0 = if exit then # 0 < if # -1 exit then # 1 ;
: 1+ # 1 + ;
: 1- # -1 + ;
: 4+ # 4 + ;
: 4- # -4 + ;
\ negate a number
: negate # 0 swap - ;
\ whitespace character constants
: bl # 32 ;
: '\n' # 10 ; 
: '\t' # 9 ;
\ character emitters
: space bl emit ;
: cr '\n' emit ;
: tab '\t' emit ;
\ literal takes whatever is on the stack and compiles it to <lit _x_>
: literal immedate ' lit , , ;
\ use literal to define character constants devised at compile-time
: '(' [ char ( ] literal ; \ )
: ')' [ char ) ] literal ;
: ':' [ char : ] literal ;
: ';' [ char ; ] literal ;
: '.' [ char . ] literal ;
: '"' [ char " ] literal ; \ "
\ when in compile mode, [compile] is used to compile the next word even if it is
\ an immediate word.
: [compile] immediate word find >cfa , ;
: recurse immediate latest @ >cfa , ;
\ define the begin <code> <condition> until construct
: begin immediate here @ ; 
: until immediate ' 0branch , here @ - , ;
\ begin <code> again construct
: again immediate ' branch , here @ - , ;
\ begin <condition> while <loop code> repeat
\ compiles to: <condition> 0branch <offset2> <loop code> branch <offset>
: while immediate ' 0branch , here @ 0 , ;
: repeat immediate
	' branch ,
	swap
	here @ - ,
	dup
	here @ swap -
	swap ! ;
\ case/of/encase
\ example:
\	case
\	test1 of ... endof
\	test2 of ... endof
\	testn of ... endof
\	... (default)
\	endcase
: case immediate # 0 ;
: of immediate
	' over ,
	' = ,
	[compile] if
	' drop , ;
: endof immediate [compile] else ; \ TODO make endof do the equivalent of else without else
: endcase immediate
	' drop ,
	begin
		dup 0<> if dup then
	while
		[compile] then
	repeat ;
\ Parenthesis-style comments
: ( immediate
	# 1 begin \ push depth, starting as 1
		key dup \ get a character
		case 
			'(' of drop 1+ endof
			')' of 1- endof
		endcase
	dup 0= until drop ; \ repeat until depth is 0
\ spaces will print out n spaces. if n < 0, then no spaces are printed.
: spaces begin dup 0> space 1- repeat drop ;
: depth ( of stack ) S0 @ DSP@ - 4- ;
\ takes an address and rounds it up to the next 4-byte cell boundary
: aligned 3 + 3 ~ & ;
: align here @ aligned here ! ;
: +! dup @ rot + swap ! ;
: c, here @ c! 1 here +! ;
\ Define literal strings with s" ..."
\ this word has to do different things depending on whether it is in compile or in immediate mode. in compile mode, we append the following to the current word: litstring <len> <string, rounded to 4-byte> in immediate mode, the string is put at here, without modifying here.
: (s") immediate here @ begin key dup '"' <> while over c! 1+ repeat drop here @ - here @ swap ;
: ]s"[ immediate
	' litstring ,
	here @
	# 0 ,
	begin
		key
		dup '"' <>
	while
		c,
	repeat
	drop
	dup
	here @ swap -
	swap # 4 -
	swap !
	align ;
: s" immediate ( -- addr len ) state @ if ]s"[ exit then (s") ;
: ." immediate
	state @ if \ compile mode
		[compile] s" ' tell , exit
	then
	begin
		key dup '"' = if drop exit then emit
	again ;
\ id. takes a word dictionary address and prints the word's name
: id. ( addr -- )
	4+
	dup c@ \ get flags and length byte
	F_LENMASK & \ get just the length
	begin
		dup 0>
	while \ while length > 0
		swap 1+
		dup c@
		emit
		swap 1-
	repeat
	2drop ;
: ?hidden 4+ c@ f_hidden & ;
: ?immediate 4+ c@ f_immed & ;
: words
	latest @
	begin
		dup 0<> if dup then
	while
		dup ?hidden not if
			dup id.	space
		then
		@
	repeat cr ;
\ Create anonymous words. Execution tokens.
: :noname 0 0 create here @ docol , ] ;
: ['] immediate ' lit , ;

